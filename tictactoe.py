import sys, pygame, copy, random, math
#Copyright 2019, Ross Metcalfe, 13/04/2019

class Gamestate:
    def __init__(self):
        #Initialise the Tic Tac Toe board, empty, turn 0, start player is crosses
        self.evalC = 0
        self.turn = 0
        self.curPlayer = 1
        self.Matrix = [[0 for x in range(3)] for y in range(3)]

    def manualMove(self, pos):#allows a move to be made by a player or any manual move
        # if pos is a correct move, do move for current player
        if (pos[0]>=0 and pos[0]<=2 and pos[1]>=0 and pos[1]<=2):
            self.Matrix[pos[0]][pos[1]] = self.curPlayer
            self.turn+=1
            self.curPlayer*=-1
    
    def getBranchCount(self):# determine the set of valid moves, store the generated moves internally as new Gamestates, return the number of valid moves c - count, self.branchStates is the new states
        c=0
        self.branchStates=[]
        temp = copy.deepcopy(self)
        for x in range(3):
            for y in range(3):
                if self.Matrix[x][y]==0:
                    c=c+1
                    newbranch = copy.deepcopy(temp)
                    newbranch.Matrix[x][y]=self.curPlayer
                    newbranch.curPlayer = self.curPlayer*-1
                    newbranch.turn+=1
                    newbranch.branchStates = []
                    newbranch.self=newbranch
                    self.branchStates.append(newbranch)
        return c
    
    def branch(self,branchIndex):# allow access to the branchStates generated by self.getBranchCount()
        return self.branchStates[branchIndex]
    
    def evalState(self):# evaluate and return the current state of the board, -1 = noughts has won, 0 = draw, 1 = crosses has won
        tictactoe.evalC+=1
        #check horizontal and vertical slices for win
        for x in range(3):
            player = self.Matrix[x][x]
            h=1
            v=1
            for y in range(3):
                if self.Matrix[x][y]!=player:
                    v=0
                if self.Matrix[y][x]!=player:
                    h=0
            if h==1 or v==1:
                return player
        #check diagonals, so check centre then check corners
        player = self.Matrix[1][1]
        if player == self.Matrix[0][0] and player == self.Matrix[2][2]:
            return player
        elif player == self.Matrix[2][0] and player == self.Matrix[0][2]:
            return player
        return 0
    
    def minmax(self):# find best move to take using minmax
        self.evalC=0
        if self.turn==0:
            rx = random.randint(0,1)
            ry = random.randint(0,1)
            self.Matrix[rx*2][ry*2]=self.curPlayer
            self.turn+=1
            self.curPlayer*=-1
            return
        bc = self.getBranchCount()
        curBoard = self.evalState()
        if curBoard!=0:
            print('Game Over, ' + str(curBoard) + ' won')
            return curBoard
        if self.turn==9:
            print('Game Over, Draw')
            return 0
        bestmove=self.curPlayer*-10
        index=0
        movescores = []
        moves = []
        
        #perform minmax tree evaluation for each move available using minmaxR() 
        for i in range(bc):
            move=self.branch(i).minmaxR(0,-10,10)
            movescores.append(move)
            moves.append(self.branch(i))
            if self.curPlayer==-1:
                bestmove = min(bestmove,move)
            else:
                bestmove = max(bestmove,move)
        bestmoves = []
        l=0
        for i in range(bc):
            if movescores[i]==bestmove:
                bestmoves.append(moves[i])
                l+=1

        index = random.randint(0,l-1)
            
        self.Matrix = bestmoves[index].Matrix
        self.turn+=1
        self.curPlayer*=-1
    
    def minmaxR(self,depth,alpha,beta):#does minmax value evaluation for a node in the search tree of moves, uses alpha beta pruning

        # keep track of depth for debugging
        depth+=1
        #get current evalState, to check if this node is a leaf (endpoint), and if so return the value of the leaf
        score = self.evalState()
        if score!=0:
            return score

        #otherwise this is a node with moves to evaluate, generate the branches...
        bc = self.getBranchCount()
        if bc==0:
            return 0

        # ..and minmaxR each one with alpha beta pruning
        bestmove=self.curPlayer*-10
        for i in range(bc):
            move = self.branch(i).minmaxR(depth,alpha,beta)
            if self.curPlayer==-1:
                #minimiser
                bestmove = min(bestmove,move)
                #if the maximiser would already choose to avoid this node entirely, stop evaluating other branches
                if bestmove < alpha:
                    return bestmove
                beta = min(beta,bestmove)
            else:
                #maximiser
                bestmove = max(bestmove,move)
                #if the minimiser would already choose to avoid this node entirely, stop evaluating other branches
                if bestmove > beta:
                    return bestmove
                alpha = max(alpha,bestmove)
            
        return bestmove
    
    def printBoard(self):
        print(self.Matrix[0])
        print(self.Matrix[1])
        print(self.Matrix[2])
        print('\n')

    def pyDrawBoard(self):
        pygame.draw.lines(screen, black, False, [(width/3, 0), (width/3, height)], 5)
        pygame.draw.lines(screen, black, False, [(2*width/3, 0), (2*width/3, height)], 5)
        pygame.draw.lines(screen, black, False, [(0, height/3), (width, height/3)], 5)
        pygame.draw.lines(screen, black, False, [(0, 2*height/3), (width, 2*height/3)], 5)
        for x in range(3):
            for y in range(3):
                cx = width/6+x*width/3
                cy =  height/6+y*height/3
                if self.Matrix[x][y]==1:
                    pygame.draw.lines(screen, red, False, [(cx-100,cy-100),(cx+100, cy+100)],4)
                    pygame.draw.lines(screen, red, False, [(cx-100,cy+100),(cx+100, cy-100)],4)
                elif self.Matrix[x][y]==-1:
                    pygame.draw.arc(screen, blue, (cx-100,cy-100,200,200), 0, 2.2*math.pi, 4)
                
#while 1:
#    pass


pygame.init()

size = width, height = 900, 900
red = (255,0,0)
green = (0,255,0)
blue = (0,0,255)
darkBlue = (0,0,128)
white = (255,255,255)
black = (0,0,0)
pink = (255,200,200)

screen = pygame.display.set_mode(size)

# main
'''
tictactoe = Gamestate()
tictactoe.printBoard()

for i in range(10):
    tictactoe.minmax()
    print(tictactoe.evalC)
    tictactoe.printBoard()
    screen.fill(white)
    tictactoe.pyDrawBoard()
    pygame.display.flip()
'''
font = pygame.font.SysFont("comicsansms", 72)
txtClr = (100, 255, 100)
textLose = font.render("You Lost", True, txtClr )
textDraw = font.render("Draw", True, txtClr )
textWin = font.render("You Won", True, txtClr )
textRestart = font.render("Press R to restart", True, txtClr ) 

tictactoe = Gamestate()
state = tictactoe.evalState()
while 1:

    
    screen.fill(white)
    
    if state==0 and tictactoe.turn<9:
        if tictactoe.curPlayer == -1:
            tictactoe.minmax()
            print(tictactoe.evalC)
            state = tictactoe.evalState()

    
    for event in pygame.event.get():
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button==1:
                mx = event.pos[0]/width
                my = event.pos[1]/height
                mx *= 3;
                my *= 3;
                mx -= 0.5
                my -= 0.5
                mx = round(mx)
                my = round(my)
                if(mx >= 0 and mx < 3 and my >= 0 and my < 3 and tictactoe.Matrix[mx][my]==0 and state==0 and tictactoe.turn<9 and tictactoe.curPlayer == 1):
                    tictactoe.manualMove((mx,my))
                    state = tictactoe.evalState()

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_r:
                tictactoe = Gamestate()
                state=0
            
        if event.type == pygame.QUIT:
            pygame.display.quit()
            pygame.quit()
            sys.exit()
    
    tictactoe.pyDrawBoard()
    if state==0 and tictactoe.turn!=9:
        pass
    else:
        s = pygame.Surface((800,300))  # the size of your rect
        s.set_alpha(200)                # alpha level
        s.fill(black)                   # this fills the entire surface
        screen.blit(s, (width//2-400,height//2-100))           # (0,0) are the top-left coordinates
        if state!=0:
            if state == 1:
                screen.blit(textWin, ((width - textWin.get_width() // 2), (height - textWin.get_height()) // 2))
            elif state == -1:
                screen.blit(textLose, ((width - textLose.get_width()) // 2, (height - textLose.get_height()) // 2))
        else:
            screen.blit(textDraw, ((width - textDraw.get_width()) // 2, (height - textDraw.get_height()) // 2))
        screen.blit(textRestart, ((width - textRestart.get_width()) // 2, 100+(height - textRestart.get_height()) // 2))
    
    pygame.display.flip()
'''
speed = [2, 2]

ball = pygame.image.load("og-image.png")
ballrect = ball.get_rect()

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT: sys.exit()

    ballrect = ballrect.move(speed)
    if ballrect.left < 0 or ballrect.right > width:
        speed[0] = -speed[0]
    if ballrect.top < 0 or ballrect.bottom > height:
        speed[1] = -speed[1]

    screen.fill(black)
    screen.blit(ball, ballrect)
    pygame.display.flip()
'''




